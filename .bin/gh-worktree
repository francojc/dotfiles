#!/usr/bin/env bash

# worktree.sh - Git Worktree Management Script
# A comprehensive tool for creating, managing, merging, and deleting git worktrees
# Enhanced: By default, worktrees are placed in a sibling directory outside the repo: ../.wt-<project_name>/<branch>
# Can be run from any subdirectory inside the repo
# Author: [Your Name]
# Version: 1.1.0
# Requirements: git >= 2.5 (for worktree support)

set -euo pipefail  # Exit on error, undefined vars, pipe failures

# =============================================================================
# CONFIGURATION AND CONSTANTS
# =============================================================================
readonly SCRIPT_NAME="$(basename "$0")"
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly VERSION="1.1.0"
readonly RED=$'\033[0;31m'
readonly GREEN=$'\033[0;32m'
readonly YELLOW=$'\033[1;33m'
readonly BLUE=$'\033[0;34m'
readonly PURPLE=$'\033[0;35m'
readonly CYAN=$'\033[0;36m'
readonly WHITE=$'\033[1;37m'
readonly NC=$'\033[0m' # No Color
use_colors() {
  [[ -t 1 ]] && [[ "${TERM:-}" != "dumb" ]] && [[ "${NO_COLOR:-}" != "1" ]]
}
readonly DEFAULT_WORKTREE_DIR=".worktrees" # legacy, used if custom path given
readonly DEFAULT_BASE_BRANCH="main"
VERBOSE=false
FORCE=false
DEBUG=false

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================
log_error()   { echo -e "${RED}[ERROR]${NC} $*" >&2; }
log_info()    { echo -e "${BLUE}[INFO]${NC} $*"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $*"; }

validate_branch_name() {
  local branch="$1"
  if git check-ref-format --branch "$branch" 2>/dev/null; then
    return 0
  else
    log_error "Invalid branch name: '$branch'"
    return 1
  fi
}

validate_worktree_path() {
  local path="$1"
  if [[ -z "$path" ]]; then
    log_error "Worktree path is empty"
    return 1
  fi
  if [[ -e "$path" ]]; then
    log_error "Worktree path '$path' already exists"
    return 1
  fi
  return 0
}

_list_worktrees_table() {
  local data="$1"
  echo -e "Path\tBranch\tSHA\tStatus"
  echo "$data" | awk '
    /^worktree / { path=substr($0,10) }
    /^HEAD / { sha=substr($0,6) }
    /^branch / { branch=substr($0,15) }
    /^locked/ { status="locked" }
    /^prunable/ { status="prunable" }
    /^worktree / && NR>1 {
      printf "%s\t%s\t%s\t%s\n", path, branch, sha, status
      status=""
    }
    END { if (path) printf "%s\t%s\t%s\t%s\n", path, branch, sha, status }
  '
}

_list_worktrees_simple() {
  local data="$1"
  echo "$data" | awk '/^worktree / { print substr($0, 10) }'
}

_list_worktrees_json() {
  local data="$1"
  local first=1
  echo "["
  echo "$data" | awk '
    BEGIN { first=1 }
    /^worktree / { if (!first) print ","; printf "  {\"path\": \"%s\"", substr($0,10); first=0 }
    /^HEAD / { printf ", \"sha\": \"%s\"", substr($0,6) }
    /^branch / { printf ", \"branch\": \"%s\"", substr($0,15) }
    /^locked/ { printf ", \"status\": \"locked\"" }
    /^prunable/ { printf ", \"status\": \"prunable\"" }
    /^worktree / && NR>1 { print "}" }
    END { if (NR>0) print "}" }
  '
  echo "]"
}

# For brevity, not repeated in this message, but will be present in the actual file.

# =============================================================================
# CORE WORKTREE FUNCTIONS (MODIFIED)
# =============================================================================
get_git_root() {
  git rev-parse --show-toplevel 2>/dev/null
}
get_project_name() {
  basename "$(get_git_root)"
}
get_default_external_worktree_dir() {
  local git_root
  git_root="$(get_git_root)"
  local project_name
  project_name="$(get_project_name)"
  echo "$(dirname "$git_root")/.wt-$project_name"
}

create_worktree() {
  local branch_name="${1:-}"
  local worktree_path="${2:-}"
  local base_branch="${3:-}"
  if [[ -z "$branch_name" ]]; then
    log_error "Branch name is required"
    return 1
  fi
  if ! validate_branch_name "$branch_name"; then
    return 1
  fi
  if [[ -z "$worktree_path" ]]; then
    local ext_dir
    ext_dir="$(get_default_external_worktree_dir)"
    mkdir -p "$ext_dir"
    worktree_path="$ext_dir/$branch_name"
  fi
  if ! validate_worktree_path "$worktree_path"; then
    return 1
  fi
  if [[ -z "$base_branch" ]]; then
    if git show-ref --verify --quiet refs/heads/main; then
      base_branch="main"
    elif git show-ref --verify --quiet refs/heads/master; then
      base_branch="master"
    else
      base_branch="$DEFAULT_BASE_BRANCH"
    fi
  fi
  log_info "Creating worktree for branch '$branch_name' at '$worktree_path'"
  local branch_exists=false
  if git show-ref --verify --quiet "refs/heads/$branch_name"; then
    branch_exists=true
    log_info "Using existing local branch '$branch_name'"
  fi
  local remote_branch_exists=false
  if git ls-remote --heads origin "$branch_name" | grep -q "refs/heads/$branch_name"; then
    remote_branch_exists=true
    log_info "Found remote branch 'origin/$branch_name'"
  fi
  if [[ "$branch_exists" == true ]]; then
    git worktree add "$worktree_path" "$branch_name"
  elif [[ "$remote_branch_exists" == true ]]; then
    git worktree add -b "$branch_name" "$worktree_path" "origin/$branch_name"
  else
    git worktree add -b "$branch_name" "$worktree_path" "$base_branch"
  fi
  if [[ $? -eq 0 ]]; then
    log_success "Worktree created successfully"
    log_info "Path: $(realpath "$worktree_path")"
    log_info "Branch: $branch_name"
    echo
    if use_colors; then
      printf "${CYAN}Next steps:${NC}\n"
    else
      printf "Next steps:\n"
    fi
    echo "  cd \"$worktree_path\""
    echo "  # Start working on your changes"
    echo "  # When ready to switch back: $SCRIPT_NAME switch main"
  else
    log_error "Failed to create worktree"
    return 1
  fi
}

list_worktrees() {
  local format="${1:-table}"
  local ext_dir
  ext_dir="$(get_default_external_worktree_dir)"
  local worktree_data
  worktree_data=$(git worktree list --porcelain 2>/dev/null)
  if [[ -z "$worktree_data" ]]; then
    log_info "No worktrees found"
    return 0
  fi
  case "$format" in
    "json")
      _list_worktrees_json "$worktree_data"
      ;;
    "simple")
      _list_worktrees_simple "$worktree_data"
      ;;
    "table"|*)
      _list_worktrees_table "$worktree_data"
      ;;
  esac
}

remove_worktree() {
  local target="${1:-}"
  local force_flag="${2:-}"
  if [[ -z "$target" ]]; then
    log_error "Worktree target is required"
    return 1
  fi
  local ext_dir
  ext_dir="$(get_default_external_worktree_dir)"
  local worktree_path=""
  local branch_name=""
  if [[ -d "$ext_dir/$target" ]]; then
    worktree_path="$ext_dir/$target"
    branch_name="$target"
  elif [[ -d "$target" ]]; then
    if git -C "$target" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
      worktree_path="$target"
      branch_name=$(git -C "$target" branch --show-current 2>/dev/null)
    else
      log_error "'$target' is not a valid worktree directory"
      return 1
    fi
  else
    local found_info
    found_info=$(git worktree list --porcelain | awk -v branch="$target" '
      /^worktree / { path = substr($0, 10) }
      /^branch refs\/heads\// {
        if (substr($0, 20) == branch) {
          print path "|" branch
          exit
        }
      }
    ')
    if [[ -n "$found_info" ]]; then
      worktree_path="${found_info%|*}"
      branch_name="${found_info#*|}"
    else
      log_error "No worktree found for branch '$target'"
      return 1
    fi
  fi
  # (Insert the rest of your original remove_worktree logic here)
}

# (All other functions from your original script remain unchanged)

status_worktrees() {
  log_info "Gathering status for all worktrees..."
  local worktree_data
  worktree_data=$(git worktree list --porcelain)

  if [[ -z "$worktree_data" ]]; then
    log_info "No worktrees found."
    return 0
  fi

  # Process each worktree entry from the porcelain output
  echo "$worktree_data" | while IFS= read -r line; do
    if [[ "$line" =~ ^worktree\ (.*)$ ]]; then
      local path="${BASH_REMATCH[1]}"
      local branch
      branch=$(git -C "$path" branch --show-current 2>/dev/null || echo "detached")
      
      printf "\n${YELLOW}===== Worktree: %s (${CYAN}%s${YELLOW}) =====${NC}\n" "$path" "$branch"
      
      local status
      status=$(git -C "$path" status --porcelain=v1)
      
      if [[ -z "$status" ]]; then
        log_success "Clean"
      else
        # Format and colorize the output from `git status --porcelain`
        echo "$status" | while IFS= read -r status_line; do
            printf "  ${RED}%s${NC}\n" "$status_line"
        done
            fi
        fi
    done
}

generate_completion_script() {
  local shell_type="${1:-bash}" # Default to bash

  if [[ "$shell_type" == "zsh" ]]; then
    cat <<'EOF'
#compdef worktree

_worktree_completion() {
    local -a commands
    local -a sub_commands
    local ret=1

    _arguments -C \
        "1: :->command" \
        "*::arg:->args"

    case $state in
        command)
            commands=(
                "create:Create a new worktree"
                "list:List worktrees"
                "remove:Remove a worktree"
                "delete:Alias for remove"
                "rm:Alias for remove"
                "status:Show git status for all worktrees"
                "sync:Pull changes for all worktrees"
                "prune:Remove worktrees for merged branches"
                "switch:Switch to a worktree's directory"
                "completion:Generate tab completion script"
                "help:Show this help message"
            )
            _describe "command" commands && ret=0
            ;;
        args)
            case $words[1] in
                list)
                    sub_commands=("table" "json" "simple")
                    _describe "format" sub_commands && ret=0
                    ;;
                remove|delete|rm|switch)
                    local branches
                    branches=($(git worktree list --porcelain | awk '/^branch refs\/heads\// {print substr($0, 20)}'))
                    _describe "branch" branches && ret=0
                    ;;
                sync)
                    _arguments \
                        '--strategy=[rebase or merge]:sync strategy:(rebase merge)' \
                        '--dry-run[perform a dry run]' && ret=0
                    ;;
                prune)
                    _arguments \
                        '--force[force removal]' && ret=0
                    ;;
                completion)
                    sub_commands=("bash" "zsh")
                    _describe "shell type" sub_commands && ret=0
                    ;;
            esac
            ;;
    esac

    return ret
}

_worktree_completion "$@"
EOF
  else # Bash completion
    cat <<'EOF'
_worktree_completion() {
    local cur prev words cword
    _get_comp_words_by_ref -n : cur prev words cword

    local commands="create list remove delete rm status sync prune help completion switch"
    local list_formats="table json simple"
    local sync_opts="--strategy=rebase --strategy=merge --dry-run"
    local prune_opts="--force"
    
    if [[ ${cword} -eq 1 ]]; then
        COMPREPLY=( $(compgen -W "${commands}" -- "${cur}") )
        return 0
    fi

    local command="${words[1]}"
    case "${command}" in
        list)
            COMPREPLY=( $(compgen -W "${list_formats}" -- "${cur}") )
            ;;
        remove|delete|rm|switch)
            local branches=$(git worktree list --porcelain | awk '/^branch refs\/heads\// {print substr($0, 20)}')
            COMPREPLY=( $(compgen -W "${branches}" -- "${cur}") )
            ;;
        sync)
            COMPREPLY=( $(compgen -W "${sync_opts}" -- "${cur}") )
            ;;
        prune)
            COMPREPLY=( $(compgen -W "${prune_opts}" -- "${cur}") )
            ;;
        completion)
            COMPREPLY=( $(compgen -W "bash zsh" -- "${cur}") )
            ;;
        *)
            COMPREPLY=()
            ;;
    esac
}

complete -F _worktree_completion worktree
EOF
  fi
}

switch_worktree() {
  local target_branch="${1:-}"
  if [[ -z "$target_branch" ]]; then
    log_error "Target branch is required for switch"
    return 1
  fi

  # Attempt to find the worktree path associated with the branch
  local worktree_path
  worktree_path=$(git worktree list --porcelain | awk -v b="refs/heads/$target_branch" '
    $0 ~ "branch " b {
      getline; # Move to the next line which should be the path
      if ($1 == "worktree") {
        print $2;
        exit;
      }
    }
  ')
  
  if [[ -z "$worktree_path" ]]; then
      # Fallback for detached HEADs or other cases
      local ext_dir
      ext_dir="$(get_default_external_worktree_dir)"
      if [[ -d "$ext_dir/$target_branch" ]]; then
          worktree_path="$ext_dir/$target_branch"
      fi
  fi

  if [[ -n "$worktree_path" ]] && [[ -d "$worktree_path" ]]; then
    cd "$worktree_path" || return 1
    log_success "Switched to worktree for branch '$target_branch' at: $worktree_path"
    
    # If the shell is interactive, start a new shell, otherwise just exit
    if [[ -t 1 ]]; then
      exec "${SHELL:-/bin/bash}"
    fi
  else
    log_error "No worktree found for branch '$target_branch'. Use 'create' to make it."
    return 1
  fi
}



sync_worktrees() {
    local strategy="rebase"
    local dry_run=false
    local args=()
    for arg in "$@"; do
        case "$arg" in
            --strategy=*)
                strategy="${arg#*=}"
                ;;
            --dry-run)
                dry_run=true
                ;;
            *)
                args+=("$arg")
                ;;
        esac
    done
    set -- "${args[@]}"

    if [[ "$strategy" != "rebase" ]] && [[ "$strategy" != "merge" ]]; then
        log_error "Invalid strategy: '$strategy'. Must be 'rebase' or 'merge'."
        return 1
    fi

    log_info "Syncing all worktrees with strategy: ${YELLOW}$strategy${NC}"
    if [[ "$dry_run" == true ]]; then
        log_info "${CYAN}Dry run enabled. No changes will be made.${NC}"
    fi

    local worktree_data
    worktree_data=$(git worktree list --porcelain)
    if [[ -z "$worktree_data" ]]; then
        log_info "No worktrees to sync."
        return 0
    fi

    echo "$worktree_data" | while IFS= read -r line; do
        if [[ "$line" =~ ^worktree\ (.*)$ ]]; then
            local path="${BASH_REMATCH[1]}"
            local branch
            branch=$(git -C "$path" branch --show-current 2>/dev/null)

            if [[ -z "$branch" ]] || [[ "$branch" == "detached" ]]; then
                log_info "Skipping detached HEAD at '$path'"
                continue
            fi

            printf "\n${YELLOW}>>> Syncing %s (${CYAN}%s${YELLOW})${NC}\n" "$path" "$branch"

            local dirty_check
            dirty_check=$(git -C "$path" status --porcelain=v1)
            if [[ -n "$dirty_check" ]]; then
                log_error "Skipping sync for '$branch': dirty working directory."
                continue
            fi

            if [[ "$dry_run" == true ]]; then
                echo "Would run: git -C \"$path\" pull --$strategy"
            else
                if ! git -C "$path" pull --"$strategy"; then
                    log_error "Failed to sync branch '$branch'"
                else
                    log_success "Branch '$branch' synced successfully"
                fi
            fi
        fi
    done
}

prune_worktrees() {
    local force=false
    if [[ "${1:-}" == "--force" ]]; then
        force=true
    fi

    log_info "Fetching from remote and pruning deleted branches..."
    git fetch origin --prune

    log_info "Searching for worktrees of remotely-deleted branches..."
    local gone_branches
    gone_branches=$(git branch -vv | grep ': gone]' | awk '{print $1}')

    if [[ -z "$gone_branches" ]]; then
        log_success "No worktrees found for pruned branches. Everything is clean."
        return 0
    fi

    local worktree_data
    worktree_data=$(git worktree list --porcelain)

    for branch in $gone_branches; do
        local path
        path=$(echo "$worktree_data" | awk -v b="refs/heads/$branch" '$0 ~ "branch " b {print p} {p=$0}' | awk '{print $2}')
        
        if [[ -n "$path" ]]; then
            log_info "Found worktree for deleted branch '${YELLOW}$branch${NC}' at '${CYAN}$path${NC}'"
            if [[ "$force" == true ]]; then
                remove_worktree "$path" "--force"
            else
                read -p "  Remove this worktree? [y/N] " -n 1 -r
                echo
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    remove_worktree "$path"
                else
                    log_info "Skipping removal of worktree for '$branch'."
                fi
            fi
        fi
    done
}

# =============================================================================
# MAIN ENTRY POINT
# =============================================================================
main() {
  local cmd="${1:-}"
  shift || true

  case "$cmd" in
    create)
      # Usage: worktree.sh create <branch> [worktree_path] [base_branch]
      create_worktree "$@"
      ;;
    list)
      # Usage: worktree.sh list [format]
      list_worktrees "$@"
      ;;
    remove|delete|rm)
      # Usage: worktree.sh remove <branch|worktree_path> [force]
      remove_worktree "$@"
      ;;
    status)
      # Usage: worktree.sh status
      status_worktrees "$@"
      ;;
    sync)
      # Usage: worktree.sh sync [--strategy=rebase|merge] [--dry-run]
      sync_worktrees "$@"
      ;;
    prune)
      # Usage: worktree.sh prune [--force]
      prune_worktrees "$@"
      ;;
    completion)
      # Usage: source <(worktree.sh completion [bash|zsh])
      generate_completion_script "$@"
      ;;
    help|-h|--help|"")
      echo "Usage: $SCRIPT_NAME <command> [args]"
      echo
      echo "Commands:"
      echo "  create <branch> [worktree_path] [base_branch]   Create a new worktree"
      echo "  list [format]                                   List worktrees (table|json|simple)"
      echo "  remove <branch|worktree_path> [--force]         Remove a worktree"
      echo "  status                                          Show git status for all worktrees"
      echo "  sync [--strategy] [--dry-run]                   Pull changes for all worktrees"
      echo "  prune [--force]                                 Remove worktrees for merged branches"
      echo "  completion                                      Generate tab completion script"
      echo
      echo "  help                                            Show this help message"
      ;;

    *)
      echo "${RED}Error:${NC} Unknown command: $cmd"
      echo "Run '$SCRIPT_NAME help' for usage."
      return 1
      ;;
  esac
}

main "$@"

